module game_engine (
    input clk,  // clock
    input rst,  // reset
    //input btn[5], // 0-A UP, 1-B CENTER, 2-C DOWN, 3-D LEFT, 4-RIGHT 
    
    input btn_a_sig,
    input btn_b_sig,
    //input btn_c_sig,
    //input btn_d_sig,
    input btn_reset_sig,
    input next_player_sig,
    
    output current_out[7],
    output target_display[7],
    output a_display[4],
    output b_display[4]
    //output c_display[4],
    //output d_display[4]

    //output target[7]
  ) {
  //const TARGET = 20; 
 
  .clk(clk) {
    ram_handler ram; //we use our ram only for storing current
    .rst(rst) {
      random random;  
      dff button_a[4](#INIT(0));
      dff button_b[4](#INIT(0));
      dff button_c[4](#INIT(0));
      dff button_d[4](#INIT(0)); 
      dff current[7](#INIT(0));  // for storing the current value in the ram temporarily for addition purpose. 
      dff target[7](#INIT(20));  //where the target value is stored for checking in state.COMPARE
      dff temp[2](#INIT(0));
      fsm state = {BEGIN, IDLE, ADDITION, COMPARE, RESULT};
   }
   
  }

    

  always {
    random.seed = 128h843233523a61357423b6225651512c62;
    random.next = btn_a_sig | btn_b_sig; //| btn_c_sig | btn_d_sig;

    current_out = 0;

   
    ram.location = 1bx;
    ram.state = 0;
    ram.in_number = 0;
    
    target_display = 0;
    a_display = 0;
    b_display = 0;
//    c_display = 0;
//    d_display = 0;
    
    case(state.q) {
      state.BEGIN:
        /* this state will 
       
           - instantiate current value to 0 (done implicitly in dff declaration)

        */

        button_a.d = random.num[2-:3] + random.num[6-:2];
        button_b.d = random.num[4-:3] + random.num[14-:2];
        button_c.d = random.num[9-:3] + random.num[5-:2];
        button_d.d = random.num[10-:3] + random.num[3-:2];
        
        ram.state=1;
        ram.location=0;
        ram.in_number=1;

        state.d = state.IDLE;
      state.IDLE:
        
        target.d = 20;
        
        ram.state = 0 ;
        ram.location = 0;
        current.d = ram.out_number;        
        
        current_out = ram.out_number;
        target_display = target.q;
        a_display = button_a.q;
        b_display = button_b.q;
        //c_display = button_c.q;                
        //d_display = button_d.q;
        
                
        if (btn_a_sig == 1) {
          state.d = state.ADDITION;
          temp.d = 0;
        } else if (btn_b_sig == 1){
          state.d = state.ADDITION;
          temp.d = 1;
     /*   } else if (btn_c_sig == 1){
          state.d = state.ADDITION;
          temp.d = 2;          
        } else if (btn_d_sig == 1) {
          state.d = state.ADDITION;
          temp.d = 3;        */
        } else if (btn_reset_sig == 1) {
          state.d = state.BEGIN; //reset button
        }

      state.ADDITION:
        /*
        This state will add the value assigned to the button to the current value.
        The addition is done automatically using the dff temp. 
           If temp.q == 0, it means that btn[1] is pressed, and thus value in button a is added to the current value.
           If temp.q == 1, it means that btn[3] is pressed, and thus value in button b is added to the current value. 
        */
        
        if (temp.q == 0) {        
          ram.state = 1;
          ram.location = 0;
          ram.in_number = current.q + button_a.q;
        }  
        else if (temp.q == 1) {
          ram.state = 1;
          ram.location = 0;
          ram.in_number = current.q + button_b.q;
        }
        else if (temp.q == 2) {
          ram.state = 1;
          ram.location = 0;
          ram.in_number = current.q + button_c.q;
        }
        else if (temp.q == 3) {
          ram.state = 1;
          ram.location = 0;
          ram.in_number = current.q + button_c.q;
        }                
        state.d = state.COMPARE;
      state.COMPARE:
        /*
        This state will check if the current value stored in the ram has exceeded the target value.
           If exceeded, 127 will be written to the ram for indication on the io_led in state.RESULT.
           If not exceeded, it will just jump to state.RESULT for assignment to current_out
        */
        if (ram.out_number >= target.q) {
          ram.state = 1;
          ram.location = 0;
          ram.in_number = 127;  //An arbitrary is used here and stored in the ram for indication on the io_led for our checking
         }  
        state.d = state.RESULT;
      state.RESULT:
        
        ram.state=0;
        ram.location=0;
        current_out=ram.out_number;
        current.d = ram.out_number;
        if (next_player_sig==1) {
          state.d = state.IDLE;  //Press btn[0] for next player's turn, and the process will repeat till the losing condition is met, and a different io_led will be shown. 
          button_a.d = random.num[2-:3] + random.num[6-:2];
          button_b.d = random.num[8-:3] + random.num[5-:2];
          button_c.d = random.num[2-:3] + random.num[11-:2];
          button_d.d = random.num[6-:2] + random.num[3-:2];
        }
        if (btn_reset_sig==1) {
          state.d = state.BEGIN; //reset button
        }
    }
  }
}